<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[R语言学习（三）矩阵]]></title>
      <url>/2017/11/15/R-programming-3/</url>
      <content type="html"><![CDATA[<p>第三章——矩阵<br><a id="more"></a></p>
<p>矩阵是一种特殊的向量，包含两个附加的属性：行数和列数。矩阵是数组的特例，数组可以大于两维，而矩阵只有两维。</p>
<h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><p>矩阵相当于按列存储一个向量，但是实际也存在矩阵类(matrix class)。<br>其中nrow或者ncol只给出一个参数也可以创建向量。</p>
<pre><code class="R">&gt; y &lt;- matrix(c(1:4), nrow = 2, ncol = 2)
&gt; y
     [,1] [,2]
[1,]    1    3
[2,]    2    4
&gt; which(y&gt;2)        #矩阵的按列存储性质
[1] 3 4
&gt; class(y)
[1] &quot;matrix&quot;
&gt; attributes(y)
$dim
[1] 2 2
</code></pre>
<p>或者先创建矩阵：</p>
<pre><code class="R">&gt; y &lt;- matrix(nrow = 2, ncol = 2)
</code></pre>
<p>再为每一个元素赋值：<code>y[1,1] &lt;- 1</code>…</p>
<p>也可以对矩阵的子矩阵进行赋值，假设y行数大于3：</p>
<pre><code class="R">y[c(1,3),] &lt;- matrix(c(1,1,8,12), nrow = 2)
</code></pre>
<p>此外，还可以用<code>rownames()</code>和<code>colnames()</code>给矩阵的行和列命名：</p>
<pre><code class="R">&gt; colnames(y) = c(&#39;a&#39;,&#39;b&#39;)
&gt; y
     a b
[1,] 1 3
[2,] 2 4
</code></pre>
<p>用<code>nrow()</code>和<code>ncol()</code>访问矩阵的行数和列数。</p>
<h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p>矩阵乘法（线性代数意义上的乘法）</p>
<pre><code class="R">&gt; y %*% y
     [,1] [,2]
[1,]    7   15
[2,]   10   22
</code></pre>
<p><code>y*3</code>代表矩阵每个元素都乘以3，而<code>y+y</code>代表矩阵每个位置对应的元素相加。</p>
<h3 id="矩阵元素筛选"><a href="#矩阵元素筛选" class="headerlink" title="矩阵元素筛选"></a>矩阵元素筛选</h3><pre><code class="R">&gt; x &lt;- matrix(c(1:6), nrow = 3)
&gt; x
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
&gt; x[x[,2] &gt;= 5,]
     [,1] [,2]
[1,]    2    5
[2,]    3    6
&gt;
</code></pre>
<p>先选出矩阵第二列大于5的元素，然后再将布尔向量应用到原矩阵中，选择出第2和3行。</p>
<p>另外一种选择方法：</p>
<pre><code class="R">&gt; x[x[,1] &gt; 1 &amp; x[,2] &gt; 5,]
[1] 3 6
&gt; x[,1]&gt;1
[1] FALSE  TRUE  TRUE
&gt; x[,2] &gt; 5
[1] FALSE FALSE  TRUE
&gt; x[,1] &gt; 1 &amp; x[,2] &gt; 5
[1] FALSE FALSE  TRUE
</code></pre>
<p>用“与”运算符<code>&amp;</code>从矩阵中选出了第一列大于1并且第二列大于5的部分。</p>
<p>要注意的是，如果只从矩阵提取一行，会自动变成向量。若仍想保留矩阵属性，需要使用<code>drop</code>参数。</p>
<pre><code class="R">&gt; dim(x)
[1] 3 2
&gt; dim(x[,1])        #此时已经成为向量，没有dim属性
NULL
&gt; dim(x[,1, drop = F])
[1] 3 1
</code></pre>
<p>也可以用<code>as.matrix()</code>将向量转化为矩阵。</p>
<h2 id="返回矩阵某元素的位置"><a href="#返回矩阵某元素的位置" class="headerlink" title="返回矩阵某元素的位置"></a>返回矩阵某元素的位置</h2><p>使用<code>row()</code>和<code>col()</code>函数查看矩阵中某元素的位置。在某些特殊情况下会用到，比如创建对称矩阵时：</p>
<pre><code class="R">&gt; m &lt;- matrix(nrow = 4, ncol = 4)
&gt; m &lt;- ifelse(row(m) == col(m), 1, 0.2)
&gt; m
     [,1] [,2] [,3] [,4]
[1,]  1.0  0.2  0.2  0.2
[2,]  0.2  1.0  0.2  0.2
[3,]  0.2  0.2  1.0  0.2
[4,]  0.2  0.2  0.2  1.0
&gt; row(m)
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    2    2    2    2
[3,]    3    3    3    3
</code></pre>
<p>可以使对角线元素为1，其余元素为0.2。</p>
<h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a><code>apply</code>函数</h2><p><code>apply(m, dimcode, f, fargs)</code></p>
<ul>
<li><code>m</code>为矩阵。</li>
<li><code>dimcode = 1</code>按行应用函数，<code>dimcode = 2</code>按列应用函数。</li>
<li><code>f</code>是函数。</li>
<li><code>fargs</code>是函数的参数。<br>如果所调用的函数的返回值是一个包含k个元素的向量，那么<code>apply()</code>的结果就有k行。有时会引起矩阵的行列数的变化，需要运行后dim检查一下结果。</li>
</ul>
<h2 id="插入或删除矩阵的行或列"><a href="#插入或删除矩阵的行或列" class="headerlink" title="插入或删除矩阵的行或列"></a>插入或删除矩阵的行或列</h2><p>向量直接使用<code>c()</code>插入：</p>
<pre><code class="R">&gt; x = c(1:7)
&gt; x = c(x[1:3], 20, x[4:7])
&gt; x
[1]  1  2  3 20  4  5  6  7
</code></pre>
<p>矩阵使用<code>cbind()</code>和<code>rbind()</code>插入列和行。<br>然而通过这两个函数若用于循环创建矩阵比较耗时，所以最好的办法是先定义好一个大矩阵然后再循环赋值。</p>
<p>想要删除矩阵的行或列，可以通过重新索引矩阵某一部分的方式，或者比如使用<code>c(-1)</code>索引行或列今儿删除矩阵的第一行或列。</p>
<h2 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h2><p>一个简单的例子，通过两个矩阵组成高维数组：</p>
<pre><code class="R">&gt; x &lt;- matrix(c(1:12), nrow = 3)
&gt; y &lt;- matrix(c(24:13), nrow = 3)
&gt; x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
&gt; y
     [,1] [,2] [,3] [,4]
[1,]   24   21   18   15
[2,]   23   20   17   14
[3,]   22   19   16   13
&gt; tests &lt;- array(data = c(x, y), dim = c(3,4,2))    #创建高维数组，其中dim中的2代表数据共有两层(两个矩阵组成)
&gt; dim(tests)        #维度由三个元素构成
[1] 3 4 2
&gt; tests
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   24   21   18   15
[2,]   23   20   17   14
[3,]   22   19   16   13

&gt; tests[3,2,1]        #返回第一个矩阵中的第三行第二列的元素
[1] 6
</code></pre>
]]></content>
      
        <categories>
            
            <category> R programming </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[R语言学习（二）向量]]></title>
      <url>/2017/11/01/R-programming-2/</url>
      <content type="html"><![CDATA[<p>第二章——向量<br><a id="more"></a></p>
<h2 id="向量性质"><a href="#向量性质" class="headerlink" title="向量性质"></a>向量性质</h2><p>可以用<code>c()</code>添加和合并向量。<br>矩阵为按列存储的向量。<br>尽量避免使用<code>for(i in 1:inlength(x))</code>在循环中，因为<code>length(x)</code>有可能为0</p>
<pre><code class="R">&gt; x &lt;- c()
&gt; x
NULL
&gt; 1:length(x)
[1] 1 0
</code></pre>
<h2 id="声明向量"><a href="#声明向量" class="headerlink" title="声明向量"></a>声明向量</h2><p>向量不需要声明，可以直接赋值。<br>先创建向量再赋值的例子</p>
<pre><code class="R">&gt; y &lt;- vector(length=2)
&gt; y
[1] FALSE FALSE
&gt; y[1] &lt;- 5
&gt; y[2] &lt;- 12
&gt; y
[1]  5 12
</code></pre>
<h2 id="循环补齐"><a href="#循环补齐" class="headerlink" title="循环补齐"></a>循环补齐</h2><p>在对两个向量运算时，如果要求这两个向量具有相同长度，则较短的向量会被循环补齐。</p>
<pre><code class="R">&gt; c(1,2,4) + c(6,0,9,20,22)
[1]  7  2 13 21 24
Warning message:
In c(1, 2, 4) + c(6, 0, 9, 20, 22) :
  longer object length is not a multiple of shorter object length
</code></pre>
<p>等同于<code>c(1,2,4,1,2) + c(6,0,9,20,22)</code></p>
<h2 id="常用向量运算"><a href="#常用向量运算" class="headerlink" title="常用向量运算"></a>常用向量运算</h2><p><code>*</code>为元素与元素相乘</p>
<pre><code class="R">&gt; c(1,2,4) * c(5,0,-1)
[1]  5  0 -4
</code></pre>
<p>负号用于删除元素，删除最后一个元素用<code>length()</code></p>
<pre><code class="R">&gt; z &lt;- c(5,12,13)
&gt; z[-1]
[1] 12 13
&gt; z[-1:-2]
[1] 13
&gt; z[1:(length(z)-1)]
[1]  5 12
</code></pre>
<p>运算符优先级问题</p>
<pre><code class="R">&gt; 1:2-1
[1] 0 1
&gt; 1:(2-1)
[1] 1
</code></pre>
<p><code>seq()</code>创建向量</p>
<pre><code class="R">&gt; seq(from=12, to=30, by=3)
[1] 12 15 18 21 24 27 30
&gt; seq(from=1.1, to=2, length=10)
 [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0
</code></pre>
<p><code>rep()</code>创建向量</p>
<pre><code class="R">&gt; rep(1:3,2)
[1] 1 2 3 1 2 3
&gt; rep(1:3,each=2)
[1] 1 1 2 2 3 3
</code></pre>
<h2 id="使用all-和any"><a href="#使用all-和any" class="headerlink" title="使用all()和any()"></a>使用<code>all()</code>和<code>any()</code></h2><pre><code class="R">&gt; x &lt;- 1:10
&gt; any(x&gt;8)
[1] TRUE
&gt; all(x&gt;8)
[1] FALSE
</code></pre>
<p>计算向量累积和<code>cumsum()</code></p>
<pre><code class="R">&gt; cumsum(1:10)
 [1]  1  3  6 10 15 21 28 36 45 55
</code></pre>
<h2 id="向量化运算符"><a href="#向量化运算符" class="headerlink" title="向量化运算符"></a>向量化运算符</h2><p>假设我们希望对向量x中每一个元素使用函数f()，很多情况下对x调用f()就可以完成。提高R代码执速度的有效方法之一是向量化，这意味着应用到向量上的函数实际上应用在其每一个元素上。</p>
<pre><code class="R">&gt; w &lt;- function(x) return(x+1)
&gt; w(c(5,2,8))
[1] 6 3 9
&gt; sqrt(1:8)
[1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
</code></pre>
<p><code>sapply(x,f)</code>对x的每一个元素使用函数f()，并将结果转化为矩阵</p>
<pre><code class="R">&gt; z12 &lt;- function(z) return(c(z,z^2))
&gt; sapply(1:8, z12)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    1    2    3    4    5    6    7    8
[2,]    1    4    9   16   25   36   49   64
</code></pre>
<h2 id="缺失值NA与NULL"><a href="#缺失值NA与NULL" class="headerlink" title="缺失值NA与NULL"></a>缺失值NA与NULL</h2><p>NA代表存在，但是缺失；NULL代表空，不存在。</p>
<pre><code class="R">&gt; x &lt;- c(1,NA,3)
&gt; mean(x)
[1] NA
&gt; mean(x, na.rm=T)
[1] 2
&gt; x &lt;- c(1,NULL,3)
&gt; mean(x)
[1] 2
&gt; x
[1] 1 3
&gt; mode(x[1])
[1] &quot;numeric&quot;
&gt; mode(x[2])
[1] &quot;numeric&quot;
</code></pre>
<p>NULL可以初始化向量</p>
<pre><code class="R">&gt; z &lt;- NULL
&gt; c(z,3)
[1] 3
&gt; z &lt;- NA
&gt; c(z,3)
[1] NA  3
</code></pre>
<p>NULL是R的一种特殊对象，它没有模式。</p>
<h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><h3 id="使用运算符-比如-gt-返回的布尔值向量对向量元素进行筛选"><a href="#使用运算符-比如-gt-返回的布尔值向量对向量元素进行筛选" class="headerlink" title="使用运算符(比如&gt;)返回的布尔值向量对向量元素进行筛选"></a>使用运算符(比如<code>&gt;</code>)返回的布尔值向量对向量元素进行筛选</h3><pre><code class="R">&gt; z &lt;- c(5,2,-3,8)
&gt; j &lt;- z*z &gt; 8
&gt; j
[1]  TRUE FALSE  TRUE  TRUE
&gt; y &lt;- c(1,2,30,5)
&gt; y[j]
[1]  1 30  5
</code></pre>
<p>另一个例子</p>
<pre><code class="R">&gt; x &lt;- c(1,3,8,2,20)
&gt; x[x &gt; 3] &lt;- 0
&gt; x
[1] 1 3 0 2 0
</code></pre>
<h3 id="使用subset-函数进行筛选"><a href="#使用subset-函数进行筛选" class="headerlink" title="使用subset()函数进行筛选"></a>使用<code>subset()</code>函数进行筛选</h3><p>可以处理缺失值NA</p>
<pre><code class="R">&gt; x &lt;- c(6,1:3,NA,12)
&gt; x[x &gt; 5]
[1]  6 NA 12
&gt; subset(x, x &gt; 5)
[1]  6 12
</code></pre>
<h3 id="使用which-函数找到满足条件元素所在的位置"><a href="#使用which-函数找到满足条件元素所在的位置" class="headerlink" title="使用which()函数找到满足条件元素所在的位置"></a>使用<code>which()</code>函数找到满足条件元素所在的位置</h3><pre><code class="R">&gt; z &lt;- c(5,2,-3,8)
&gt; which(z*z &gt;8)
[1] 1 3 4
&gt; which(z*z &gt;8)[1]    #找到满足条件元素首次出现的位置
[1] 1
</code></pre>
<h2 id="向量化的ifelse-函数"><a href="#向量化的ifelse-函数" class="headerlink" title="向量化的ifelse()函数"></a>向量化的<code>ifelse()</code>函数</h2><p><code>ifelse(b,u,v)</code><br>如果<code>b[i]</code>为真，则返回值的第i个元素为<code>u[i]</code>，否则为<code>v[i]</code></p>
<pre><code class="R">&gt; x &lt;- c(5,2,9,12)
&gt; ifelse(x &gt; 6, 2*x, 3*x)
[1] 15  6 18 24
</code></pre>
<p><code>diff()</code>函数比较向量每个元素和后面的元素之差<br><code>sign()</code>函数将向量中的数值转化为1、0或者-1</p>
<pre><code class="R">&gt; u &lt;- c(1,6,7,2,3,5)
&gt; diff(u)
[1]  5  1 -5  1  2
&gt; sign(diff(u))
[1]  1  1 -1  1  1
</code></pre>
<h2 id="测试向量相等"><a href="#测试向量相等" class="headerlink" title="测试向量相等"></a>测试向量相等</h2><p>使用<code>all()</code>函数</p>
<pre><code class="R">&gt; x &lt;- 1:3
&gt; y &lt;- c(1,2,4)
&gt; x == y
[1]  TRUE  TRUE FALSE
&gt; all(x == y)
[1] FALSE
</code></pre>
<p>符号:产生的是整数，而<code>c()</code>产生的是浮点数，<code>identical(x,y)</code>判断两个对象是否完全一样</p>
<pre><code class="R">&gt; x &lt;- 1:2
&gt; y &lt;- c(1,2)
&gt; all(x == y)
[1] TRUE
&gt; identical(x,y)
[1] FALSE
&gt; typeof(x)
[1] &quot;integer&quot;
&gt; typeof(y)
[1] &quot;double&quot;
</code></pre>
<h2 id="向量元素的名称"><a href="#向量元素的名称" class="headerlink" title="向量元素的名称"></a>向量元素的名称</h2><p>使用<code>name()</code>给向量中的元素命名，或查询向量元素名称</p>
<pre><code class="R">&gt; x &lt;- 1:3
&gt; x
[1] 1 2 3
&gt; names(x) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;)
&gt; names(x)
[1] &quot;a&quot;  &quot;b&quot;  &quot;ab&quot;
&gt; x
 a  b ab 
 1  2  3 
 &gt; x[&quot;b&quot;]
b 
2
</code></pre>
<h2 id="c-的强制类型转换"><a href="#c-的强制类型转换" class="headerlink" title="c()的强制类型转换"></a><code>c()</code>的强制类型转换</h2><pre><code class="R">&gt; c(5,2,&quot;abc&quot;)
[1] &quot;5&quot;   &quot;2&quot;   &quot;abc&quot;
&gt; c(5,2,c(1.5,6))
[1] 5.0 2.0 1.5 6.0
</code></pre>
]]></content>
      
        <categories>
            
            <category> R programming </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Running Lemon-Tree on Arg1.CD68 High-correlated Modules]]></title>
      <url>/2017/10/26/run-lemon-tree/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><ul>
<li>For WGCNA: transcriptomics data with stable patients, same classification as Jan’s version.</li>
<li>For Lemon-Tree: transcriptomics data with 7 modules on all patients. See the file arg1.cd68.stable.pdf.</li>
<li>Modules: indianred3, lightslateblue, brown4, mediumpurple4, orangered1, yellowgreen, firebrick4.</li>
<li>Preprocess: Scale the feature to standard normal distribution before running the Lemon-Tree program.</li>
</ul>
<h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><ol>
<li>From WGCNA results on stable patients, select 7 interesting modules (5 positive correlation, 2 negative correlation to Arg1.CD68) including 1645 unique genes.</li>
<li>From 1645 genes select candidate regulators according to GO annotation. 205 candidates were selected.<br>GO:0004871, signal transducer activity<br>GO:0000989, transcription factor activity, transcription factor binding</li>
<li>Run Lemon-Tree on the 1645 genes with all stable and unstable patients. Clustering result of Lemon-Tree includes 36 clusters with 1456 genes.</li>
<li>Assign 205 candidate regulators on 36 clusters. 100 highest assignments were selected. 35 of all clusters have regulators. 74 unique regulators were selected.<br>Frequency of regulators occurred more than one time: BRD7(3), ENY2(2), EVI2A(3), GPR65(3), GRN(4), HEYL(6), LANCL1(2), MAP4K4(2), NMI(3), RERE(2), ROR(2), SETD3(2), SS18L2(2), TGFB1I1(2), TOB1(2) </li>
<li>GO enrichment analysis on the 35 clusters.</li>
<li>Trace the genes back from WGCNA modules. Most of the genes gathering in one Lemon-Tree cluster are also belong to one WGCNA module.</li>
<li>Calculate the genes to WGCNA eigengene. Regulator genes tend to have higher correlation to the corresponding WGCNA eigengene.</li>
</ol>
<h2 id="Possible-Improvements"><a href="#Possible-Improvements" class="headerlink" title="Possible Improvements"></a>Possible Improvements</h2><ol>
<li>Check the regulators which regulate more than one cluster.</li>
<li>Check the GO results to find interesting clusters.</li>
<li>Add miRNA as regulators.</li>
</ol>
<h2 id="Variables-in-R"><a href="#Variables-in-R" class="headerlink" title="Variables in R"></a>Variables in R</h2><ul>
<li><code>transcriptomics.stable</code>    #WGCNA data</li>
<li><code>moduleColors.stable</code>    #WGCNA modules</li>
<li><code>regulators.old</code>        # GO:0004871 &amp; GO:0000989 genes</li>
<li><code>stable.arg1.modules</code>    #7 interesting modules</li>
<li><code>stable.arg1.genes</code>    #selected genes from 7 modules</li>
<li><code>arg1.transcriptomics.stableandunstable.scaled</code>        #scaled data for Lemon-Tree, 1645 genes</li>
<li><code>ID.nodup/arg1.transcriptomics.IDs</code>    #ID information</li>
<li><code>arg1.regulators.old</code>    #candidate regulators for 7 modules</li>
<li><code>tight.clusters.su</code>    #Lemon-Tree clustering result, 1456 genes</li>
<li><code>top.regs.su.old</code>        #top 100 regulator assignments</li>
<li><code>reg.list.su.old</code>        #regulator list for output</li>
<li><code>reg.gene.list.su.old</code>    $regulator and gene list for output</li>
</ul>
<h2 id="Lemon-Tree程序的基本步骤"><a href="#Lemon-Tree程序的基本步骤" class="headerlink" title="Lemon Tree程序的基本步骤"></a>Lemon Tree程序的基本步骤</h2><h3 id="ganesh"><a href="#ganesh" class="headerlink" title="ganesh"></a>ganesh</h3><p>通过gibbs sampling进行双向聚类：</p>
<ol>
<li>随机分配N个gene到K0个类，随机分配M个样本到Lk,0个样本类。</li>
<li>N次循环，从某类中随机删除gene i，对每个类，以及i单独成为一类的情况，计算将i放入k中的贝叶斯概率。</li>
<li>经过n次迭代得到稳定的聚类结果。</li>
</ol>
<h3 id="tight-cluster"><a href="#tight-cluster" class="headerlink" title="tight_cluster"></a>tight_cluster</h3><h3 id="regulators"><a href="#regulators" class="headerlink" title="regulators"></a>regulators</h3><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>首先要标准化 scale features</p>
<p>其次要选择candidate regulator genes from GO annotation</p>
<h2 id="相关文献-References"><a href="#相关文献-References" class="headerlink" title="相关文献 References"></a>相关文献 References</h2><ul>
<li>Segal E, Shapira M, Regev A, Pe’er D, Botstein D, et al.(2003) <a href="https://www.nature.com/articles/ng1165" target="_blank" rel="external">Module networks: identifying regulatory modules and their condition-specific regulators from gene expression data</a>. Nature Genetics 34: 166–167.</li>
<li>Bonnet E, Calzone L, Michoel T. (2015) <a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003983" target="_blank" rel="external">Integrative multi-omics module network inference with Lemon-Tree</a>. PLoS Comput Biol 11(2): e1003983.</li>
<li>Joshi A, Van de Peer Y, Michoel T (2008) <a href="https://academic.oup.com/bioinformatics/article/24/2/176/2748127/Analysis-of-a-Gibbs-sampler-method-for-model-based" target="_blank" rel="external">Analysis of a Gibbs sampler for model based clustering of gene expression data</a>. Bioinformatics 24: 176–183.</li>
<li>Joshi A, De Smet R, Marchal K,Van de Peer Y, Michoel T( 2009) <a href="https://academic.oup.com/bioinformatics/article/25/4/490/249900/Module-networks-revisited-computational-assessment" target="_blank" rel="external">Module networks revisited: computational assessment and prioritization of model predictions</a>. Bioinformatics 25: 490- 496.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Research </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[R语言学习（一）入门]]></title>
      <url>/2017/10/26/R_programming_1/</url>
      <content type="html"><![CDATA[<p><a href="https://cran.r-project.org" target="_blank" rel="external">R语言</a>免费，开源，语法简单，适合从事数学、统计学等非计算机人员学习使用。<br>此文以一个计算机专业人员的角度学习和使用R语言。<br><a id="more"></a></p>
<h2 id="运行R程序"><a href="#运行R程序" class="headerlink" title="运行R程序"></a>运行R程序</h2><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><pre><code class="R">&gt; source(&quot;z.R&quot;)
</code></pre>
<h3 id="批处理模式-ubuntu-terminal"><a href="#批处理模式-ubuntu-terminal" class="headerlink" title="批处理模式(ubuntu terminal)"></a>批处理模式(ubuntu terminal)</h3><pre><code>$ R CMD BATCH z.R
</code></pre><h2 id="R语言函数的变量作用域"><a href="#R语言函数的变量作用域" class="headerlink" title="R语言函数的变量作用域"></a>R语言函数的变量作用域</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>只有函数体内部可见的变量是“局部变量”</p>
<pre><code class="R">&gt; x &lt;- 5
&gt; f &lt;- function() x &lt;-4
&gt; f()
&gt; x
[1] 5
</code></pre>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是在函数之外创建的变量，在函数内部也可以访问。<br>可以通过&lt;&lt;-在函数内部给全局变量赋值</p>
<pre><code class="R">&gt; y &lt;- 4
&gt; f &lt;- function(x) y &lt;&lt;- 3
&gt; f()
&gt; y
[1] 3
</code></pre>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><pre><code class="R">&gt; g &lt;- function(x, y=2, z=T){...}
</code></pre>
<h2 id="R语言的数据结构"><a href="#R语言的数据结构" class="headerlink" title="R语言的数据结构"></a>R语言的数据结构</h2><h3 id="1-向量-Vector"><a href="#1-向量-Vector" class="headerlink" title="1. 向量 Vector"></a>1. 向量 Vector</h3><p>向量是R语言的核心。一个向量内部的数据类型是单一的，不可以由整数元素和字符串混合构成。<br>在R语言中即使单个的数实际上也是由向量所表示的</p>
<pre><code class="R">&gt; x &lt;- 8
&gt; x
[1] 8
</code></pre>
<h3 id="2-字符串-Character"><a href="#2-字符串-Character" class="headerlink" title="2. 字符串 Character"></a>2. 字符串 Character</h3><pre><code class="R">&gt; y &lt;- &quot;abc&quot;
&gt; y
[1] &quot;abc&quot;
&gt; length(y)
[1] 1
</code></pre>
<h4 id="字符串连接与分割"><a href="#字符串连接与分割" class="headerlink" title="字符串连接与分割"></a>字符串连接与分割</h4><p>使用<code>paste</code>连接字符串，用<code>strsplit</code>分割字符串</p>
<pre><code class="R">&gt; u &lt;- paste(&quot;abc&quot;, &quot;de&quot;, &quot;f&quot;)
&gt; u
[1] &quot;abc de f&quot;
&gt; v &lt;- strsplit(u, &quot; &quot;)
&gt; v
[[1]]
[1] &quot;abc&quot; &quot;de&quot;  &quot;f&quot;  

&gt; v[[1]]
[1] &quot;abc&quot; &quot;de&quot;  &quot;f&quot;  
&gt;
</code></pre>
<h3 id="3-矩阵-Matrix"><a href="#3-矩阵-Matrix" class="headerlink" title="3. 矩阵 Matrix"></a>3. 矩阵 Matrix</h3><p>也可以理解为按列存放的向量</p>
<pre><code class="R">&gt; m &lt;- rbind(rnorm(2), rnorm(2))
&gt; m
           [,1]       [,2]
[1,] 0.07614777 0.26227249
[2,] 0.81721921 0.05898863
&gt; m[3]
[1] 0.2622725
&gt;
</code></pre>
<h3 id="4-列表-List"><a href="#4-列表-List" class="headerlink" title="4. 列表 List"></a>4. 列表 List</h3><h4 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h4><pre><code class="R">&gt; x &lt;- list(u = 2, v = &quot;abc&quot;)
&gt; x
$u
[1] 2

$v
[1] &quot;abc&quot;

&gt; x$u
[1] 2
</code></pre>
<h4 id="列表作为函数返回值"><a href="#列表作为函数返回值" class="headerlink" title="列表作为函数返回值"></a>列表作为函数返回值</h4><pre><code class="R">&gt; hn &lt;- hist(Nile)
&gt; hn
$breaks
 [1]  400  500  600  700  800  900 1000 1100 1200 1300 1400

$counts
 [1]  1  0  5 20 25 19 12 11  6  1

$density
 [1] 0.0001 0.0000 0.0005 0.0020 0.0025 0.0019 0.0012 0.0011 0.0006 0.0001

$mids
 [1]  450  550  650  750  850  950 1050 1150 1250 1350

$xname
[1] &quot;Nile&quot;

$equidist
[1] TRUE

attr(,&quot;class&quot;)
[1] &quot;histogram&quot;
</code></pre>
<p>注意<code>attr</code>后面的内容，标志了hn的属性<em>histogram</em><br><br><br>也可使用<code>str()</code>输出列表，更为直观</p>
<pre><code class="R">&gt; str(hn)
List of 6
 $ breaks  : int [1:11] 400 500 600 700 800 900 1000 1100 1200 1300 ...
 $ counts  : int [1:10] 1 0 5 20 25 19 12 11 6 1
 $ density : num [1:10] 0.0001 0 0.0005 0.002 0.0025 0.0019 0.0012 0.0011 0.0006 0.0001
 $ mids    : num [1:10] 450 550 650 750 850 950 1050 1150 1250 1350
 $ xname   : chr &quot;Nile&quot;
 $ equidist: logi TRUE
 - attr(*, &quot;class&quot;)= chr &quot;histogram&quot;
</code></pre>
<h3 id="5-数据框-Data-Frame"><a href="#5-数据框-Data-Frame" class="headerlink" title="5. 数据框 Data Frame"></a>5. 数据框 Data Frame</h3><p>实际上是列表，只不过每个列表存储着一列向量。<br><code>data.frame</code>通常通过读取文件来创建，此处不再举例。</p>
<h3 id="6-类-Class"><a href="#6-类-Class" class="headerlink" title="6. 类 Class"></a>6. 类 Class</h3><p>R语言是一门面向对象的编程语言。每一个对象都有其类别属性，R语言的泛型函数可以根据变量的类别来执行。<br>通过<code>class()</code>查看变量的类</p>
<pre><code class="R">&gt; hn &lt;- hist(Nile)
&gt; class(hn)
[1] &quot;histogram&quot;
</code></pre>
<p><br><br>通过<code>attributes()</code>查看变量的属性，可以直接使用<code>属性(变量)</code>语句</p>
<pre><code class="R">&gt; attributes(hn)
$names
[1] &quot;breaks&quot;   &quot;counts&quot;   &quot;density&quot;  &quot;mids&quot;     &quot;xname&quot;    &quot;equidist&quot;

$class
[1] &quot;histogram&quot;

&gt; names(hn)
[1] &quot;breaks&quot;   &quot;counts&quot;   &quot;density&quot;  &quot;mids&quot;     &quot;xname&quot;    &quot;equidist&quot;
</code></pre>
<h2 id="总结变量（对象）的类型"><a href="#总结变量（对象）的类型" class="headerlink" title="总结变量（对象）的类型"></a>总结变量（对象）的类型</h2><pre><code class="R">&gt; m &lt;- rbind(rnorm(2), rnorm(2))
&gt; m
           [,1]       [,2]
[1,] 0.07614777 0.26227249
[2,] 0.81721921 0.05898863
&gt; typeof(m)
[1] &quot;double&quot;
&gt; mode(m)
[1] &quot;numeric&quot;
&gt; attributes(m)
$dim
[1] 2 2

&gt; class(m)
[1] &quot;matrix&quot;
</code></pre>
<h2 id="清空环境变量"><a href="#清空环境变量" class="headerlink" title="清空环境变量"></a>清空环境变量</h2><pre><code>rm(list = ls())
</code></pre>]]></content>
      
        <categories>
            
            <category> R programming </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[博士学习计划]]></title>
      <url>/2017/10/25/study_plan/</url>
      <content type="html"><![CDATA[<p>毕业之前应当要完成的事。<br><a id="more"></a></p>
<h2 id="应掌握的技能"><a href="#应掌握的技能" class="headerlink" title="应掌握的技能"></a>应掌握的技能</h2><ul>
<li>精通R语言，以计算机专业人员而非统计学家那样使用R语言。</li>
<li>掌握spark分布式计算，学习scala，具备分布式编程能力。</li>
<li>追踪最新的机器学习算法，比如深度学习和神经网络等，学习CUDA。</li>
</ul>
<h2 id="应发表的文章"><a href="#应发表的文章" class="headerlink" title="应发表的文章"></a>应发表的文章</h2><ul>
<li>一作SCI： 3-5篇，应有1-2篇高质量文章</li>
<li>非一作SCI： 若干</li>
</ul>
<p>目前一篇Nature Communications在投。</p>
<h2 id="应去国家"><a href="#应去国家" class="headerlink" title="应去国家"></a>应去国家</h2><ul>
<li>已去过：英国、法国、德国、美国、荷兰、比利时、意大利、西班牙、葡萄牙、奥地利、瑞典、丹麦、卢森堡、土耳其、匈牙利、斯洛伐克、斯洛文尼亚、罗马尼亚、梵蒂冈、摩纳哥、新加坡、印度尼西亚、</li>
<li>将来要去：摩洛哥、希腊、俄罗斯、芬兰、爱沙尼亚、拉脱维亚、立陶宛、波兰、挪威、冰岛、保加利亚、克罗地亚、塞尔维亚、阿根廷、南极</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Others </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
